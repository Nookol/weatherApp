{"version":3,"file":"standardize-geolocation.umd.js","sources":["../src/index.ts"],"sourcesContent":["export interface StandardizedGeolocation {\n  elevation?: number;\n  latitude: number;\n  longitude: number;\n}\n\nexport type PointInput = string | number;\n\nexport interface GeoJSONPoint {\n  coordinates: PointInput[];\n  type: string;\n}\n\nexport type WithElevation =\n  | { alt: PointInput }\n  | { altitude: PointInput }\n  | { elev: PointInput }\n  | { elevation: PointInput };\n\nexport type WithLatitude = { lat: PointInput } | { latitude: PointInput };\n\nexport type WithLongitude =\n  | { lon: PointInput }\n  | { lng: PointInput }\n  | { long: PointInput }\n  | { longitude: PointInput };\n\nexport type GeolocationInput =\n  | readonly PointInput[]\n  | (Partial<WithElevation> & WithLatitude & WithLongitude)\n  | { location: GeolocationInput }\n  | { position: GeolocationInput }\n  | GeoJSONPoint\n  | { geometry: GeoJSONPoint };\n\nexport function createPoint(\n  rawLatitude: PointInput,\n  rawLongitude: PointInput,\n  rawElevation?: PointInput\n): StandardizedGeolocation {\n  const latitude = maybeGetNumber(rawLatitude);\n\n  if (latitude === undefined) {\n    throw new TypeError('`latitude` is required but not found');\n  }\n\n  if (latitude > 90 || latitude < -90) {\n    throw new RangeError('`latitude` should be between -90 and 90');\n  }\n\n  const longitude = maybeGetNumber(rawLongitude);\n\n  if (longitude === undefined) {\n    throw new TypeError('`longitude` is required but not found');\n  }\n\n  if (longitude > 180 || longitude < -180) {\n    throw new RangeError('`longitude` should be between -180 and 180');\n  }\n\n  const elevation = maybeGetNumber(rawElevation);\n\n  return { elevation, latitude, longitude };\n}\n\nexport function getElevation(point: Partial<WithElevation>): PointInput {\n  if ('elevation' in point) {\n    return point.elevation;\n  } else if ('alt' in point) {\n    return point.alt;\n  } else if ('altitude' in point) {\n    return point.altitude;\n  } else if ('elev' in point) {\n    return point.elev;\n  }\n}\n\nexport function getLatitude(point: WithLatitude): PointInput {\n  if ('latitude' in point) {\n    return point.latitude;\n  } else if ('lat' in point) {\n    return point.lat;\n  }\n}\n\nexport function getLongitude(point: WithLongitude): PointInput {\n  if ('longitude' in point) {\n    return point.longitude;\n  } else if ('lng' in point) {\n    return point.lng;\n  } else if ('lon' in point) {\n    return point.lon;\n  } else if ('long' in point) {\n    return point.long;\n  }\n}\n\nfunction isGeoJSONPoint(point: GeolocationInput): point is GeoJSONPoint {\n  return 'coordinates' in point && point.type === 'Point';\n}\n\n// HACK: This is a workaround for TypeScript not properly narrowing readonly arrays\nfunction isArray(array: any): array is ReadonlyArray<any> {\n  return Array.isArray(array);\n}\n\nfunction maybeGetNumber(value: any): number | undefined {\n  const valueAsNumber = Number(value);\n  return isNaN(valueAsNumber) ? undefined : valueAsNumber;\n}\n\nexport function standardizeGeolocation(\n  point: GeolocationInput\n): StandardizedGeolocation {\n  if (isArray(point)) {\n    // Geolocation points must have 2 or 3 elements\n    if (point.length !== 2 && point.length !== 3) {\n      throw new TypeError(\n        'point array must have exactly 2 or 3 numeric elements'\n      );\n    }\n\n    return createPoint(point[0], point[1], point[2]);\n  }\n\n  if (isGeoJSONPoint(point)) {\n    // GeoJSON points are in [longitude, latitude] order\n    return createPoint(point.coordinates[1], point.coordinates[0]);\n  }\n\n  if ('geometry' in point) {\n    return standardizeGeolocation(point.geometry);\n  }\n\n  if ('location' in point) {\n    return standardizeGeolocation(point.location);\n  }\n\n  if ('position' in point) {\n    return standardizeGeolocation(point.position);\n  }\n\n  const elevation = getElevation(point);\n  const latitude = getLatitude(point);\n  const longitude = getLongitude(point);\n\n  return createPoint(latitude, longitude, elevation);\n}\n\nexport default standardizeGeolocation;\n"],"names":["createPoint","rawLatitude","rawLongitude","rawElevation","latitude","maybeGetNumber","undefined","TypeError","RangeError","longitude","elevation","getElevation","point","alt","altitude","elev","getLatitude","lat","getLongitude","lng","lon","value","valueAsNumber","Number","isNaN","standardizeGeolocation","array","Array","isArray","length","type","isGeoJSONPoint","coordinates","geometry","location","position"],"mappings":"kQAmCO,SAASA,EACdC,EACAC,EACAC,OAEMC,EAAWC,EAAeJ,WAEfK,IAAbF,QACI,IAAIG,UAAU,2CAGlBH,EAAW,IAAMA,GAAY,SACzB,IAAII,WAAW,+CAGjBC,EAAYJ,EAAeH,WAEfI,IAAdG,QACI,IAAIF,UAAU,4CAGlBE,EAAY,KAAOA,GAAa,UAC5B,IAAID,WAAW,oDAKhB,CAAEE,UAFSL,EAAeF,GAEbC,SAAAA,EAAUK,UAAAA,GAGzB,SAASE,EAAaC,SACvB,cAAeA,EACVA,EAAMF,UACJ,QAASE,EACXA,EAAMC,IACJ,aAAcD,EAChBA,EAAME,SACJ,SAAUF,EACZA,EAAMG,UADR,EAKF,SAASC,EAAYJ,SACtB,aAAcA,EACTA,EAAMR,SACJ,QAASQ,EACXA,EAAMK,SADR,EAKF,SAASC,EAAaN,SACvB,cAAeA,EACVA,EAAMH,UACJ,QAASG,EACXA,EAAMO,IACJ,QAASP,EACXA,EAAMQ,IACJ,SAAUR,EACZA,YADF,EAcT,SAASP,EAAegB,OAChBC,EAAgBC,OAAOF,UACtBG,MAAMF,QAAiBhB,EAAYgB,EAGrC,SAASG,EACdb,MAVec,EAYHd,EAXLe,MAAMC,QAAQF,GAWD,IAEG,IAAjBd,EAAMiB,QAAiC,IAAjBjB,EAAMiB,aACxB,IAAItB,UACR,gEAIGP,EAAYY,EAAM,GAAIA,EAAM,GAAIA,EAAM,IApBjD,IAAiBc,KALjB,SAAwBd,SACf,gBAAiBA,GAAwB,UAAfA,EAAMkB,KA2BnCC,CAAenB,UAEVZ,EAAYY,EAAMoB,YAAY,GAAIpB,EAAMoB,YAAY,OAGzD,aAAcpB,SACTa,EAAuBb,EAAMqB,aAGlC,aAAcrB,SACTa,EAAuBb,EAAMsB,aAGlC,aAActB,SACTa,EAAuBb,EAAMuB,cAGhCzB,EAAYC,EAAaC,UAIxBZ,EAHUgB,EAAYJ,GACXM,EAAaN,GAESF"}